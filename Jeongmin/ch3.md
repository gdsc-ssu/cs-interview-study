## 미디어 타입

- MIME타입
  - http는 웹에서 전송되는 객체 각각에 MIME타입을 붙인다
  - MIME은 전자메일 시스템에서 메세지가 오갈 때 겪는 문제점 해결하기 위해 설계됨
  - 멀티미디어 콘텐츠 기술하고 라벨 붙이기 위해 채택
  - 이미지 파일 보여주고, HTML 파일 분석 및 포멧팅, 오디오 파일 재생 등등
  - html로 작성된 텍스트 문서는 text/html
  - jpeg는 image/jpeg

## URI

- 서버 리소스는 통합 자원 **식별자** 또는 uri
- https://jungking/

## URL

- 통합 자원 지시자
  - 리소스 식별자의 가장 흔한 형태
  - URL은 특정 서버의 한 리소스에 대한 **구체적인 위치 서술**
  - https://jungking/11

## URN

- URI의 두번째 종류
- 유니폼 리소스 이름
- 콘텐츠 이루는 한 리소스에 대해 그 리소의 위치에 영향 받지 않는 유일무이한 이름

## 트랜잭션

- **요청명령과 응답결과로 구성됨**
- http 메시지라고 불리는 정형화된 데이터 덩어리를 이용해 이루어짐
  - 메서드
    - 모든 http요청 메세지는 한개의 메서드를 가짐
    - 서버에게 어떤 동작이 취해져야하는지
      - 웹페이지 가져오기, 게이트웨이 프로그램 실행하기
      - GET, PUT, DELETE , POST

## TCP/IP

- http서버의 ip주소와 포트번호를 어떻게 알아낼까?
  - URL을 사용하면됨!
  - URL에 포트번호가 있고, DNS를 통해 OP주소로 바꿀 수 있다

## 웹의 구성 요소

- 프록시
  - 클라이언트와 서버 사이에 위치한 http중개자
- 캐시
  - 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 http창고
- 게이트웨이
  - 다른 어플리케이션과 연결된 특별한 웹 서버
- 터널
  - 단순히 http통신을 전달하기만 하는 특별한 프락시

## 프락시

- 웹 보안, 애플리케이션 통합, 성능 최적화를 위한 중요한 구성요소
- 프락시는 클라이언트와 서버 사이에 위치하여 클라이언트의 모든 http요청을 받아 서버에 전달
- 신뢰할 수 있는 중재자 역할
- 요청과 응답을 필터링

## 캐시

- 자주 찾는 것의 사본을 저장해두는 특별한 http 프락시 서버

## 게이트웨이

- 다른 서버들의 중개자로 동작하는 특별한 서버
- **http트래픽을 다른 프로토콜로 변환하기 위해 사용**
- 게이트웨이는 언제나 스스로가 리소스를 갖고 있는 진짜 서버인것 처럼 요청을 다룸
- 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못함

## 터널

- 두 커넥션 사이에서 raw 데이터를 열어보지 않고 그대로 전달해주는 http 애플리케이션
- http 터널은 주로 비 http 데이터를 하나 이상의 http 연결을 통해 그대로 전송해주기 위해 사용
- 암호화된 SSL 트래픽을 http커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽 통과

## URL

- 인터넷 리소스를 가리키는 표준 이름
- 어디에 있고 어떻게 접근할 수 있는지?
- URI는 URL과 URN으로 이루어져 있음
- 대부분의 URL은 `스킴://서버위치/경로 구조`로 이루어짐

## URL 문법

- url로 인터넷의 모든 리소스를 찾을 수 있고, 그 리소스들은 http,ftp,smtp를 통해 접근할 수 있다.
- url 스킴의 문법은 9개 부분으로 나뉨
  - <스킴>://<사용자이름>:<비밀번호>\*<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프레그먼트>
- 스킴
  - 주어진 리소스에 어떻게 접근하는지 알려주는 중요한 정보
  - 예시 : http
- 경로
  - 리소스가 서버의 어디에 있는지
  - /seasonal/index.html
- 파라미터
  - url 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요함
  - **프로토콜 파라미터가 없으면 다른 한편에 있는 서버는 그 요청을 잘못 처리하거나 처리하지 않을것**
  - **애플리케이션 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터 받는데 사용**
  - http://a.com/gnu`;type=d`
  - type=d 라는 한개의 파라미터 전달
- 질의 문자열
  - ?item=17231
  - uRL의 질의 컴포넌트는 게이트웨이를 가리키는 URL의 경로 컴포넌트를 가리킨다
- 프레그먼트
  - 리소스의 특정 부분 가리킬수 있도록 프레그먼트 제공
  - /tools.html#drills
  - /tools.html의 웹페이지 일부
- 인코딩
  - 안전하지 않은 문자를 인코딩 해야함!

# 3장

- 인바운드
  - 메세지가 원서버로 향하는 것
- 아웃바운드
  - 모든 처리가 끝난 뒤에 메세지가 사용자 에이전트로 들어오는것
- 업스트림
- 다운스트림
  - 모든 메세지는 다운스트림으로 흐른다

## 메세지 문법

- 메서드
  - 안전한 메서드
    - GET,HEAD
      - HEAD는 응답으로 헤더만 돌려주고, 본문은 반환안됨. 그러면 HEAD 왜 쓰지?
      - 리소스 가져오지 않아도 타입 확인
      - 상태코드를 통해 개체가 존재하는지 확인
      - 리소스 변경 확인
    - PUT vs PATCH
      [POST, PUT, PATCH의 차이점 | 토스페이먼츠 개발자센터](https://docs.tosspayments.com/blog/rest-api-post-put-patch)
      - PUT
        - /payments/1과 같이 특정 리소스의 URI로 요청을 보내야 리소스 생성됨
        - 멱등해야하기에 리소스 전체를 업데이트
      - PATCH
        - 특정 리소스 URI를 명확하게 알아야함.
        - 부분업데이트
          - 멱등하지 않음, 안전하지 않음
        - RFC문서에서는 PATCH에 넣을 데이터가 PUT에 넣을 데이터보다 크다면 PUT쓰는것을 권장
    - TRACE
      - 요청이 방화벽등 애플리케이션 통과 가능
      - 클라이언트에게 자신의 요청이 서버에 도달했을때 어떻게 보이는지 알려줌
      - 목적지 서버에서 루프백 진단 시작
      - 자신이 보낸 메세지가 망가졌거나 수정되었는지 확인
      - 주로 진단을 위해 사용
    - DELETE
      - 클라이언트는 삭제가 수행되는 것을 보장하지 못함
      - 서버가 클라이언트에게 알리지 않고 요청 무시하는것을 허용하기 때문
- 상태코드
  - 클라이언트들에게 그들의 트랜잭션을 이해할 수 있는 쉬운방법 제공
  - except 헤더
    - HTTP `Expect` 헤더는 클라이언트가 서버에 특정 기대 사항을 전달할 때 사용됩니다. 가장 일반적으로 사용되는 값은 `100-continue`로, 클라이언트가 대용량의 데이터를 서버로 전송하기 전에 서버가 준비되었는지 확인하기 위해 사용됩니다.
  - 100~199
    - 정보성 상태코드
      - 100 continue : http 클라이언트 애플리케이션이 서버에 엔터티 본문 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할때 확인 작업 최적화
      - 클라이언트 입장 : 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않을 목적으로만 사용
      - 서버입장 : 절대로 100-continue 응답을 받을 것을 의도하지 않은 클라이언트에게 100continue 보내서는 안됨
      - 프락시 입장 : 클라이언트로 부터 100-continue 응답을 의도한 요청을 받은 프락시는 만약 다음 홉 서버가 http/1.1을 따르거나 어떤 버전을 따르는지 모른다면 except레더를 포함시켜 요청을 다음으로 전달해야
      - **HTTP 100 Continue 상태 코드는 클라이언트가 서버에 요청 헤더를 전송한 후, 서버로부터 본문 데이터를 전송해도 좋다는 신호를 받을 때 사용됩니다**
  - 200~299
    - 성공
    - 201 : 서버 개체 생성하라는 요청
    - 202 : 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않음
    - 204 :헤더는 있는데 본문은 없음
    - 205 : html 폼에 있는 모든 값 비워라
  - 300~399
    - 리다이렉션
    - 클라이언트가 관심있어하는 리소스에 대해 다른 위치를 사용하라고 말해주고나 그 리소스의 내용 대신 다른 대안 응답 제공
    - 리다이렉트 될 url에 대한 링크와 설명을 포함하는 것이 좋은 습관
    - 301 : 요청한 url이 옮겨졌을 때
    - 302 : 301과 같음
    - 303 : 클라이언트에게 리소스를 다른 url에서 가져와야한다고 말해주고자 할때
      - 주 목적은 POST요청에 대한 응답
      - 클라이언트에게 리소스의 위치를 알려줌
    - 304 : 조건부 요청
    - 305 : 리소스가 프락시를 통해 접근되어야함
- 헤더

  - 클라이언트와 서버가 무엇을 하는지 결정하기 위해 사용
  - 일반헤더
    - 클라이언트,서버 양쪽 모두가 사용
    - 기본적인 내용
    - Date, Connection, MIME-Version,
  - 요청 헤더
    - 요청메세지를 위한 헤더
      - 요청 메세지에서만 의미 가짐
    - 클라이언트가 받고자하는 데이터 타입이 무엇인지 서버에게 제공
    - Accept : _ / _
      - 어떤 미디어 타입도 받아들일 것
    - Accept 헤더
      - 자신의 선호와 능력을 알려줌
      - 추가정보를 활용해 무엇을 보낼것인가에 대해 똑똑한 결정 내림
      - 원하는 것을 정확하게 얻기에 대역폭 낭비 안함
    - 조건부 요청 헤더
      - 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 할 수 있음
      - Except헤더
        - 클라이언트가 요청에 필요한 서버의 행동을 열거하게 해줌
    - 요청 보안 헤더
      - 요청을 위한 간단한 인증요구/응답체계
      - 리소스에 접근하기 전에 자신을 인정
      - Authorization
      - Cookie
  - 응답헤더

    - 클라이언트에게 정보를 제공하기 위한 자신만의 헤더
    - 클라이언트가 어떤 서버와 대화하고 있는지
    - 클라이언트에게 부가 정보 제공
    - Age헤더
      - 응답이 얼마나 오래되었는가
    - 협상 헤더
      - HTML문서에 독일어,프랑스어로 번역돼서 여러표현이 존재하는 경우 → 어떤걸 선택할지
    - 응답보안 헤더
      - Set-Cookie

  - 엔터티 헤더
    - 엔터티 본문에 대한 헤더
    - 수신자에게 자신이 다루는 것이 무엇인지 말해줌
    - Content-type : text/html;
    - 콘텐츠 헤더
      - 콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할때 유용하게 활용될 수 있는 것들
      - Content-Type, Content-Length

### 지속커넥션

- HTTP요청을하기 시작한 애플리케이션은 웹 페이지 내 이미지 가져오기 위해 그 서버에 또 요청을 할 것
  - 사이트 지역성
- 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션이 지속커넥션
- 지속커넥션 재사용함으로써, 커넥션 맺기 위한 준비작업에 따르는 시간 절약 가능

### 지속커넥션이 병렬커넥션에 비해 갖는 장점

- 커넥션을 맺기 위한 사전 작업과 지연을 줄여줌
- 튜닝된 커넥션을 유지
- 커넥션 수를 줄여줌
- 지속 커넥션을 잘못 관리할 경우, 계속 연결된 상태로 수많은 커넥션이 쌓이게됨
  - 지속커넥션은 병렬커넥션과 함께 사용될 때 효과적
  - 현재 웹 애플리케이션은 적은 수의 병렬 커넥션만 맺고 그것을 유지

### Keep-Alive

- 지속 커넥션 타입은 두개
  - keep-alive
    - http 1.0
    - 요청 응답후 연결 종료 → Keep alive 헤더를 붙여야 연결이 유지됨
  - 지속 커넥션
    - http 1.1
    - 연결 유지
  - **HTTP/1.0**: `Connection: Keep-Alive` 헤더를 명시해야 함.
  - **HTTP/1.1**: 기본적으로 연결이 유지되며, 종료하려면 `Connection: close` 헤더를 사용해야 함.
- Keep-alive 옵션
  - 커넥션을 유지하기 바라는 요청
  - 언제든지 현재의 Keep-alive 커넥션을 끊을 수 있으며 keep-alive 커넥션에서 처리되는 트랜잭션 수 제한 가능
  - timeout 파라미터, max 파라미터 등이 있는데 →이거대로 동작하는 보장 x
- keep alive 제한과 규칙
  - 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알고 있어야 커넥션이 유지될 수 있음
  - 정확한 Content-Length와 함께 멀티파트 미디어 형식 , 청크 전송 인코딩으로 인코딩 돼야
  - 프락시와 게이트웨이는 커넥션 헤더 규칙을 정화히 지켜야

### Keep alive와 멍청한 프락시

- 프락시는 connection 헤더를 이해하지 모함
- 해당 헤더를 삭제하지 않고 요청 그대로 다음 프락시에 전달
  - Conncetion 헤더는 홉 바이 홉 헤더이기 때문에 다음 서버로 전달되서는 안된다
- 프락시는 커넥션이 끊어지기 전까지 계속 끊어지길 기다림
  - 타임아웃 날때까지 기다림
- 피하기 위해선
  - Connection , keep-alive헤더 절대 전달해서는 안된다
- 대신
  - Proxy-Connection 헤더를 사용
- 홉 바이 홉 헤더는 하나의 특정 커넥션에서 쓰이고 그 이후에는 절다하면 안됨
  - 서버가 그 헤더를 자신과 프락시 간의 커넥선에 대한 것으로 오해하면서부터 문제가 생기기 때문
- ProxyConnection
  - 헤더가 웹서버에 전달되더라도 클라이언트와 프락시 혹은 프락시와 서버 사이에 keep-alive 커넥션이 맺어지지 않음
- 예시 상황
  - 멍청한 프록시는 **`Connection` 헤더를 그대로 전달**해버립니다.
    - 클라이언트 → 프록시: `Connection: Keep-Alive`
    - **프록시가 헤더를 제거하지 않고** 서버로 전송: `Connection: Keep-Alive`
    - 서버는 이 헤더를 보고 **프록시와의 연결을 유지**하려고 시도하지만, 실제로는 **프록시가 중간에서 연결을 닫을 수도 있음**.

### 지속 커넥션

- 모든 메세지가 자신의 길이 정보를 정확히 가지고 있을때에만 커넥션을 지속시킬 수 있음
  - Content-Length값을 가지거나 청크 전송 인코딩으로 인코드 되어있어야
- http/1.1기기는 Connection 헤더 값과는 상관없이 언제나 커넥션을 끊을 수 있고, 중간에 끊어지는 커넥션을 복구할 수 있어야만 함

### 응답 엔터티

- 응답 메세지는
  - MIME 타입을 서술하는 Content-Type헤더
  - 응답 본문의 길이를 서술하는 Content-Length헤더
  - 실제 응답 본문의 내용

### 리다이렉션

- 영구히 리소스가 옮겨진 경우
  - 301 상태코드
- 임시로 리소스가 옮겨진 경우
  - 이름변경이 임시적이기에 서버는 클라이언트가 나중에는 원래 url로 찾아오길 원함
  - 303,307 상태코드
- URL 증가
  - 문맥 정보 포함시키기 위해 재작성된 URL로 리다이렉트
  - 요청이 도착했을때 서버는 상태 정보 내포한 새 URL 생성하고 사용자를 이 새 URL로 리다이렉트
  - 303,307
- 과부하된 서버가 요청 받으면
  - 303,307

## 웹 중개자

- 클라이언트 입장에서 트랜잭션 수행하는 중개인
- 웹서버이기도 하고 웹 클라이언트 이기도 함
- 개인 프락시
  - 하나의 클라이언트를 위함
- 공유 프락시
  - 여러 클라이언트가 함께 사용
- 프락시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션 연결, 게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상 연결
  - 게이트웨이는 중개자 보다는 변환기 느낌

## 왜 쓸까?

- 보안 개선
- 성능 높여줌
- 비용 절약
- 모든 http 트래픽 들여다보고 건들이기 가능
- 예시
  - 어린이 사용자 보호하는 필터
  - 문서 접근 제어 필터
  - 보안 방화벽
  - 리버스 프락시
    - 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션
  - 콘텐츠 라우터
    - 인터넷 트래픽 조건과 콘텐츠 종류에 따라 요청을 특정 웹서버로 유도하는 콘텐츠 라우터로 동작
  - 트랜스 코딩
    - 클라이언트에게 콘텐츠 전달하기 전 본문 포맷 수정
  - 익명화 프락시
    - http메세지에서 신원을 식별할 수 있는 특성 ip주소, 쿠키 등등을 제거해서 개인정보 보호

## 어디에 있을까?

- 출구 프락시
  - 로컬 네트워크의 출구에 프락시를 둔다
- 접근 프락시
  - ISP접근지점에 위치
    - 사용자의 다운로드 속도 개선,인터넷 대역폭 비용 줄이기 위해 캐시 프락시 사용
- 대리 프락시
  - **리버스 프락시**
  - **네트워크의 가장 끝에 있는 웹 서버의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할때만 웹서버에게 자원 요청**
- 네트워크 교환 프락시
  - 캐시를 이용해 인터넷 교차로의 혼잡 완화 트래픽 흐름을 감시하기 위햐 충분한 처리 능력 갖춘 프락시가 네트워크 사이의 인터넷 피어링 교환지점들에 놓임
- 프락시 계층
  - 부모-자식 관계
  - 정적임
  - 동적을으로 부모를 선택할 수도 있음
    - 로드 밸런싱
    - 지리적 인접성에 근거한 라우팅
- 어떻게 프락시가 트래픽을 처리?
  - 클라이언트 트래픽이 프락시로 가게하는 방법은 4가지
  - 클라이언트 수정하기
    - 크롬은 수동 혹은 자동 프락시 설정 지원
    - http요청을 원서버가 아닌 프락시로
  - 네트워크 수정하기
    - 네트워크 인프라를 가로채서 웹 트래픽을 프락시로 가게
    - DNS이름공간 수정
    - 웹서버 수정
- 정리

| **방법**                           | **설명**                                            | **장점**                       | **단점**                            |
| ---------------------------------- | --------------------------------------------------- | ------------------------------ | ----------------------------------- |
| **클라이언트 수정**                | 브라우저나 애플리케이션에서 수동/자동 프록시 설정   | 간단한 설정, 개별 제어 가능    | 대규모 환경에서 비효율적            |
| **네트워크 수정**                  | 라우터/방화벽 설정으로 트래픽 리디렉션              | 전체 네트워크 트래픽 제어 가능 | 네트워크 복잡성 증가                |
| **DNS 이름공간 수정**              | DNS 서버 조작으로 도메인 요청을 프록시로 유도       | 도메인 기반 제어 가능          | 보안 취약점, HTTPS 인증서 문제 발생 |
| **웹서버 수 조정 (역방향 프록시)** | 프록시 서버가 트래픽을 받아 여러 웹서버로 분산 처리 | 부하 분산 및 가용성 향상       | 프록시 서버 관리 복잡성 증가        |

- DNS 스푸핑
  - **DNS 응답을 조작**해, 사용자가 **잘못된 IP 주소**로 연결되게 만드는 공격이
- 리버스 프록시
  - **클라이언트의 요청을 받아 내부 서버로 전달**하고, 서버의 응답을 **클라이언트에게 대신 반환**하는 중개 서버에요. 일반 프록시(포워드 프록시)는 클라이언트가 외부에 요청을 보낼 때 중계하는 반면, 리버스 프록시는 **서버 측**에서 요청을 받아 **트래픽을 분산**하거나 **보안**을 강화하는 역할을 해요.

### 개별 접촉

- http는 익명으로 사용하며 상태가 없다

### http헤더

- User-Agent : 사용자의 브라웢
- Referer : 사용자가 현재 링크를 타고 온 근원 페이지
  - 현재 사이트로 유입하게한 페이지

### 클라이언트 ip주소

- 클라이언트 ip주소는 사용하는 컴퓨터를 가리킴. 사용자가 같은 컴퓨터 사용하면 그들을 식별할 수 없음
- isp가 동적으로 할당하기에 사용자 ip로 식별 불가
- NAT사용하면서 실제 Ip주소를 하나의 방하벽 ip로 바꾼다
- HTTP프락시와 게이트웨이는 원 서버에 새로운 TCP연결을 한다. 웹 서버는 클라이언트의 IP대신 프락시 서버의 IP를 본다

### 뚱뚱한 URL

- 사용자의 상태 정보를 포함하고 있는 URl
- HTTP트랜잭션을 하나의 세션 혹은 방문으로 묶는 용도로 뚱뚱한 URL 사용가능
- 사이트를 브라우징 하는 사용자를 식별 가능

### 쿠키

- 사용자를 식별하고 세션을 유지하는 방식
- 캐시나 브라우저는 쿠키에 있는 내용물 캐싱하지 않음
- 쿠키의 타입
  - 세션 쿠키, 지속쿠키
    - 세션쿠키는 사용자가 사이트 탐색할때 선호사항 저장
    - 지속쿠키는 디스크에 저장되어 브라우저 닫거나 컴퓨터 재시작해도 남아있음 사용자가 주기적으로 방문하는 사이트에 대한 설정정보나 로그인 이름 유지
    - Expires 혹은 Max-Age 파라미터가 없으면 세션쿠키
- 동작 방식
  - 사용자가 다시 돌아왔을떄 그 사용자를 식별하기 위해 유일한 값을 쿠키에 할당
  - set-cookie해서 응답헤더에 기술되어 사용자에 전달
- 클라이언트 측 상태
  - 브라우저가 서버 관련 정보를 저장하고 사용자가 해당 서버에 접근할 때 마다 그 정보를 함께 전송하는 메커니즘
  - 서버에 접근할 때 마다 그 정보를 함께 전송하게 하게 함.
  - 브라우저는 쿠키정보를 저장할 책임이 있는데 이 시스템을 클라이언트측 상태
- 사이트마다 다른 쿠키들
  - 브라우저는 수백 수천개의 쿠키를 가질 수 있지만 그렇다고 브라우저가 쿠키 전부를 모든 사이트에 보내지 않음
  - 보통 두세개 정도의 쿠키만 보냄
    - 성능저하 때문
    - 쿠키는 대부분 서버에 특화된 이름/값 쌍을 가짐
  - 많은 광곧ㄹ은 웹사이트에 일부인것 처럼 제작되고 지속쿠키로 만들어짐
    - Referer헤더를 통해 사용자의 프로필과 웹사이트 사용하는 습관에 대한 데이터 구축
- 속성
  - domain
    - domain: “a.com”이면 a.com도메인을 가지고 있는 모든 사이트에 전달하라는거
  - path
    - path: “/auto”
      - auto페이지에서 사용자가 좋아하는 자동차의 크기를 기록하려고 쿠키 사용
      - Set-cookie : pref=compact;domain=”a.com”;path=/autos/
      - /auto 페이지에 접근하면 Pref정보도 얻는다!
- Version2 Cookie
  - 쿠키마다 목적을 설명하는 설명문이 있음
  - 파기 주기에 관계 없이 브라우저가 닫히면 쿠키 강제 삭제 가능
  - 절대 날짜 값대신에 초 단위의 상대값으로 쿠키의 생명주기 결정할 수 있는 Max-Age
  - url의 포트번호로 쿠키 제어 가능
  - `이름 : 값,` `verison` 이 필수속성임!

### 인증,인가

- 인증
  - 너 누구야
  - 비밀번호 요구
- 인가
  - 사용자가 어떤 행동을 할 수 있는지 정해주는
  - 프리미엄 사용자 / 일반사용자
  - 관리자/ 일반회원

### 인증

- 내가 누구인지 증명하는것
- http는 기본인증, 다이제스트 인증이라는 두가지 공식적인 인증 프로토콜이 존재
  - WWW-Authenticate
  - Authorization
  - Authentication-Info

### 기본인증

- /a/jeff.jpg 요청하면
- WWW-Authenticate와 함께 비밀번호 요구
- 기본인증은 Authentication-Info는 사용하지 않음

### Base64

- 사용자 이름이나 비밀번호 보내야할때 유용

### 프락시 인증

- 중개 프락시 서버를 통해 인증
- 회사 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시서버를 거치게 함
- 회사 리소스 전체에 대해 통합적인 접근 제어를 하기위해 프락시 서버 사용하면 좋음

### 보안적인 결함

- Base64디코딩이 쉽기 때문에 SSL위에서 적용할수 있음
- 대안
  - 다이제스트 인증
    - 비밀번호를 **암호화된 형태**로 전송하여 **기본 인증(Basic Authentication)**보다 **더 안전**하게 데이터를 보호합니다.
    - **MD5 해시 알고리즘**을 이용해 사용자 이름, 비밀번호, 서버에서 제공하는 임의의 값(**nonce**) 등을 조합하여 생성된 해시 값을 서버로 전송합니다.
    - HTTPS와 비교 시 여전히 **안전성이 낮음**
    - 대체 기술
      - OAuth2.0
      - JWT
      - https
      - **OAuth란? OAuth의 동작 방식은?**
        사용자의 비밀번호 없이도 접근 권한을 위임받을 수 있습니다. 사용자가 유저이고, 소비자가 앱/웹 서비스이고, 서비스제공자가 구글이라고 했을 때 OAuth의 동작 방식은 소비자가 Request Token을 요청하면, 서비스제공자가 Request Token을 발급해줍니다. 사용자 인증 페이지 호출이 되고 사용자 로그인이 완료되면, 사용자의 권한 요청 및 수락이 되면서 Access Token을 발급되고 이를 통해 서비스 정보를 요청합니다.
        **8. JWT방식과 Session방식의 차이**
      - Session은 서버의 메모리를 사용하여 데이터를 저장하고, 로컬에는 세션 ID만을 쿠키에 저장하여 이를 서버로 보내 데이터를 받아오는 방식이므로, 매번 유저가 요청할 때마다 전체 데이터를 보내주어 서버에 과부하가 생길 위험이 큽니다.
      - JWT는 필요한 정보를 payload에 담고, 암호화/복호화 데이터를 header에 넣어 한 번에 암호화하고, 이 토큰을 서버에 보내 검증 여부만 서버에서 전송받으므로 서버에 무리가 덜하지만 토큰을 탈취당하면 보안상 문제가 발생할 수 있습니다.

### https

- 모든 http요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 된다.
- SSL이라는 소켓 계층 또는 TLS를 통해 이루어짐

### 보안

- 대칭키 알고리즘
- 공개키 비대칭 알고리즘
  - RSA
  - 디지털 서명
    - 누가 메세지를 썼는지 알려주고 그 메세지가 위조되지 않았음을 증명하기 위해 메세지에 서명

### 디지털 인증서

- certs
- 구성
  - 대상의 이름(사람,서버,조직), 유효기간, 인증서 발급자, 인증서 발급자의 디지털 서명
- 인증서를 개인키로 서명
- 표준은 없지만 x.509 v3인증서를 사용함

### 서버 인증을 위한 인증서

- https를 통한 안전한 웹 트랜잭션을 시작할때 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서 가져옴
- 과정
  - 브라우저가 인증서 받음
  - 서명기관 검사
    - 신뢰할만한 곳이면 그것의 공개키를 미리 알고 있을 것

### https

- 보안 전송계층을 통해 전송되는 http
- https는 http메세지를 tcp로 보내기 전에 그것을 암호화하는 보안 계층으로 보냄
- 현재는 ssl → tls
- ssl 트래픽은 바이너리 프로토콜이기 때문에 443번 포트를 통해 전달
- 과정
  - 클라이언트는 먼저 웹서의 443번 포트로 연결
  - tcp연결이 되고 난 후 클라이언트와 서버는 교환키 협상하면서 ssl계층 초기화
  - 핸드세이크 완료후 ssl 초기화 완료
  - 클라이언트는 요청메세지를 보안 계층에 보냄
  - 메세지는 tcp로 보내지기 전에 암호화됨

### SSL핸드세이크

- 프로토콜 버전 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원 인증
- 채널 암호화 하기 위한 임시 세션키 생성

### 가상 호스팅

- 하나의 서버에 여러 호스트

### 진짜 https클라이언트

- ssl클라이언트와 서버 프로그래밍을 쉽게 만들어주는 라이브러리들이 존재
- open ssl

### 프락시

- 대부분의 회사는 기업 네트워크와 공공 인터넷을 잇는 경계에 보안을 위한 프락시 설치
- 프락시는 http만 인식하는데 브라우저가 https를 쓰면 프락시는 알수가 없음!
- https ssl 터널링 프로토콜
  - 클라가 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해줌
  - 클라이언트는 이 내용을 프락시가 읽을 수 있도록 암호화 전 평문으로 말해줌

### 리다이렉션과 부하 균형

- 리다이렉션 장치들은 몇가지 방식의 부하균형을 포함
- 들어오는 메세지의 부하를 서버들의 집합에게 분산하게 됨

### 리다이렉션 프로토콜

- http 메세지를 가용한 웹 서버로 가급적 빨리 보내는게 목표
- 트래픽이 다른 서버나 프락시를 통해 벡터 트래픽으로 리다이렉트 하기 위해 사요됨
- https 리다이렉션
  - 리다이렉트하는 서버가 클라이언트의 Ip주소를 안다는 장점이 있음
  - 장점
    - 서버로 향하는 요청의 방향 변경
  - 단점
    - 어떤 서버로 리다이렉트 할지 결정하려면 원서버는 상당히 많은 처리를 해야함
    - 페이지 접근할때마다 두번의 왕복 필요
    - 리다이렉트 서버 고장 시 사이트 고장
- dns 리다이렉션
  - dns결정 알고리즘
  - 라운드로빈
    - 가장 흔함
    - 전체의 부하 균형을 유지하기 위해 dns호스트명 분석 기능 사용
    - 서버에 대한 클라이언트의 상대적 위치나 서버의 현재 스트레스 고려 안함
    - 대부분의 dns클라이언트는 다중 주소 집합의 첫번째 주소를 사용함
    - 부하 균형을 위해 대부분의 **dns 서버는 룩업이 끝났을때 마다 주소를 순환시킴**
      - **이것을 dns 라운드로빈이라고 부름**
  - dns 캐싱
    - 호스트 하나에 대해 한번의 dns룩업이 수행한 뒤 그 주소를 몇번이고 다시 사용
      - 룩업 비용 줄이기 가능
      - 클라이언트와 계속 대화하는 것을 선호하는 서버들도 있음
    - dns 라운드로빈은 이러한 이유로 하나의 클라이언트로 인한 부하를 제대로 분산하지 못함
    - 비슷한 요청을 하는 클라이언트 수가 어느정도 많아야함
  - 다른 dns기반 리다이렉션 알고리즘
    - 부하 균형 알고리즘
      - 몇몇 dns서버는 웹 서버의 로드를 추적하고 가장 로드가 적은 웹 서버 목록의 가장 위에 놓음
    - 근접 라우팅 알고리즘
      - 웹 서버들의 위치가 분산된 경우 사용자 근처의 웹서버로 보낸다
    - 결합 마스킹 알고리즘
      - dns서버는 네트워크의 건강 상태 모니터링하고 요청을 정전이나 기타 장애를 피해서 라우팅
  - 단점
    - 권위 있는 dns서버가 결정을 내리기 위해 사용하는 유일한 정보가 클라이언트 ip주소가 아닌 로컬 dns서버의 주소라는것
- 임의 캐스트 어드레싱
  - 같은 IP 주소를 가진 여러 서버 중에서 가장 가까운 서버로 데이터를 보내는 방식
  - 지리적으로 흩어진 웹서버들은 정확히 같은 아이피 주소 가지고 클라이언트의 요청을 클라이언트에서 가장 가까운 서버로 보내주기 위해 **백본 라우터의 최단거리 라우팅 능력에 의지**
  - 각 웹서버에게 자신을 인접한 백본 라우터로 향하는 라우터라고 광고
  - 백본 라우터
    - 네트워크의 중심 역할을 하는 대형라우터
  - 웹 서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본 라우터와 대화
  - 백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을 때 그 아이피 주소를 받아들일 수 있는 가장 가까운 라우터를 찾는다
  - 백본 라우터는 패킷을 보낸다
  > 💡 상황
  >
  > - YouTube 같은 서비스가 있고, 전 세계 여러 곳에 YouTube 서버가 있음.
  > - 이 서버들은 **같은 IP 주소(예: `192.168.1.1`)를 사용**함.
  > - 사용자가 YouTube에 접속하면 **가장 가까운 서버로 연결**됨.
  📌 **백본 라우터가 애니캐스트 요청을 처리하는 과정**
  1️⃣ **각 서버는 "나는 `192.168.1.1` 주소를 받을 수 있어!"라고 광고(라우팅 프로토콜 사용)**
  - 서버들은 자신과 연결된 **백본 라우터에게 "이 IP 주소로 오는 요청은 나한테 보내!"라고 광고**함.
  - 즉, **"나는 YouTube 서버야!"** 라고 백본 라우터에게 알리는 것.
  2️⃣ **백본 라우터가 애니캐스트 IP를 학습**
  - 여러 서버가 동일한 `192.168.1.1`을 가지고 있으므로
  - 백본 라우터는 어느 서버가 "더 가까운지" 확인함.
  - 즉, **"YouTube 서버는 여러 곳에 있지만, 어느 경로가 가장 빠를까?"를 결정하는 것.**
  3️⃣ **사용자가 YouTube 접속 (ex. `192.168.1.1` 요청 보냄)**
  - 한국에서 접속하면 **한국에 있는 YouTube 서버**로
  - 미국에서 접속하면 **미국에 있는 YouTube 서버**로 가도록 **백본 라우터가 패킷을 보냄**.
  4️⃣ **백본 라우터는 최적 경로를 선택해서 패킷 전달**
  - 백본 라우터는 받은 요청을 보고
  - **"192.168.1.1을 받을 수 있는 가장 가까운 서버는 어디지?"** 라고 판단함.
  - 그리고 가장 가까운 서버로 요청을 전달! 🚀
- 아이피 맥 포워딩
  - IP 주소를 MAC 주소로 변환해서 패킷을 전달하는 방식
  - 컴퓨터가 IP 주소(예: `192.168.1.10`)로 패킷을 보내려고 함.
  - 하지만 데이터가 실제로 네트워크에서 이동하려면 **MAC 주소(물리적 주소)**가 필요함.
  - 이때 **ARP (Address Resolution Protocol)**을 사용해서 IP → MAC 변환.
  - 변환된 MAC 주소를 이용해 목적지로 패킷을 전달함.
  - **같은 네트워크** 안에서는 **IP → MAC 변환 후 데이터 전송**
  - LAN환경에서 많이 쓰임
- 아이피 주소 포워딩
  - IP 주소를 변경하거나 다른 네트워크로 패킷을 보내는 방식
  1. 네트워크에서 패킷이 특정 목적지로 가야 함.
  2. 만약 네트워크 주소가 변경되거나 NAT(Network Address Translation)가 적용되면,
  3. **원래 목적지 MAC 주소가 아니라 IP 주소를 기반으로 패킷을 전달**함.
  4. 라우터가 패킷을 받아서, 적절한 IP 주소로 변경한 뒤 다시 전송!
  5. **다른 네트워크**로 데이터를 보내려면 **IP 주소를 기준으로 패킷을 전달** (IP 주소 포워딩)
  6. WAN환경에서 많이쓰임
