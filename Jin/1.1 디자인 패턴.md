
## 1.1.1 싱글톤 패턴
**하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴**

### 싱글톤 패턴이 필요한 이유?
> 왜 객체(인스턴스)가 하나여야만 하지?
> -> 인스턴스 생성 비용을 아끼기 위해서

### 싱글톤의 단점
- TDD가 어렵다. 
	- 싱글톤에서는 하나의 미리 만들어진 인스턴스를 가지고 돌려쓰는 것인데, 테스트 코드에서 항상 해당 인스턴스를 가지게 하기가 어렵다.
	그렇다면 어떻게 해결하냐, 의도적으로 미리 넣어준다. -> 의존성 주입 (DI)를 하면 된다!
	싱글톤은 모듈간의 결합을 강하게 만들지만, DI를 통해 결합을 느슨하게 만들 수 있다.

> 싱글톤은 왜 결합을 강하게 만들지? 
> -> 하나를 가지고 계속 돌려쓰니까. 그게 아니면 안되게 만들어버렸는데, 계속해서 넣어줘야만 하니까.

의존성 = 종속성으로, A가 B에 의존한다는 것은, B의 변화로 인해 A도 변해야한다는 것

메인 모듈 하나에서 서브모듈로 일일이 하나하나 주입하던 것을, 의존성 주입자(Dependency Injector)가 가로채서 넣어준다. 그렇게 되면 메인 모듈과 서브 모듈 간의 의존성이 떨어지게 된다. 

> 서브모듈이라는 표현이 적절할까? 책에서는 하위 모듈이라고 나와있긴하다.
> 
> 그렇다면 모듈은 뭘까?
> 모듈은 기능 단위로 코드를 쪼갠 것이다. 단순히 쪼갰다 보다, 하나의 "기능" 단위로 쪼갰다에 초점을 맞추면 될 것 같다. 독립적인 기능이라고 생각하면 되겠다. 
> 모듈화를 하면 유지보수와 재사용성이 높은 코드를 짤 수 있다. 가장 큰 고민은, *어느 정도로 작게 모듈을 분리할 것인가*가 될 것 같다.
> 
> 여기서 객체지향과 모듈화가 어느정도 비슷한 의미를 가지는 것 같은데, 뭐가 다른지도 봐보자.
> 캡슐화를 해서 다른 곳에서 가져다 쓸 수 있지만, 다른 점이 존재한다. 

|       | 클래스(객체=인스턴스) | 모듈                                        |
| ----- | ------------ | ----------------------------------------- |
| 인스턴스화 | O            | X                                         |
| 상속    | O            | X                                         |
| 목적    | 객체를 만들기 위해   | 클래스에 메소드를 제공하기 위해 (클래스에서 사용할 기능을 제공하기 위해) |



### 의존성 주입

- 의존성 주입의 장점
	- 모듈들을 교체하기 쉬운 구조가 된다. 결합력이 낮아져서 가능해진 것
	- 테스트와 마이그레이션 하기 쉽다. 
	- 구현에 있어서 추상화 레이어를 넣고, 이를 기반으로 구현체를 넣어주기 때문에 의존성의 방향이 일관된다.

- 의존성 주입의 단점
	- 모듈들의 분리가 더 많아져서, 클래스의 수가 많아진다. ~~그래서 나같은 초보자한테는 뭐가 어디있는지, 찾기 어려울수도..~~

- 의존성 주입의 원칙
	- "상위 모듈은 하위모듈에서 어떠한 것도 가져올 수 없다."
	
## 1.1.2 팩토리 패턴

공장을 생각하면 쉽다.
인스턴스 생성을 공장으로 분리한다.

- 인스턴스 생성
- 상위 클래스
	- 뼈대를 결정하고
- 하위 클래스
	- 구체적인 내용을 정의한다.
---
- 상위 클래스와 하위 클래스가 나눠지기에 느슨한 결합을 가진다. 
- 팩토리로 인스턴스 생성을 위임해, 상위클래스에서는 인스턴스의 생성방식에 대해서 알필요가 없어져서 유연하다. 
- 객체 생성이 떨어져 있기 때문에 리팩토링에도 부담이 없다. <- 한 곳만 고치면 되기 때문!

[제대로 이해하는 싱글톤패턴](https://www.youtube.com/watch?v=DHo8qRCtmGU)
## 1.1.3 전략  패턴

**객체의 행위를 바꾸고 싶은 경우, 직접 수정하지 않고, 전략이라고 부르는 "캡슐화된 알고리즘"을 컨택스트 안에서 바꿔주면서 상호 교체가 가능하게 만든다.** 

정리하자면, 객체가 행하는 행위에 대해서 캡슐화를 진행한다.

제대로 이해한 것인지는 모르겠지만, 예를 들자면 이러하다.

- 책에 있는 예시 1
	- 라인 카드와 카카오 카드로 결제를 하려 한다. 라인 카드와 카카오 카드에 필요한 개인 정보의 종류와 가짓수는 다르다. pay 메소드 자체를 조건을 거는게 아니라, pay 메소드의 파라미터 자체를 "결제방식"으로 추상화 해서 라인카드가 들어가던, 카카오 카드가 들어가던 하게 하는 것이다. 
	```kotlin
	//결제 부
	pay(KAKAOCard("qqq@email.com","qlalfqjsgh"))

	// 함수 구현부
	fun pay(payment: Payment){
	
	}


	//클래스 구현부
	class KAKAOCard : Payment(){
	//이메일, 비밀번호 등
	}
	```
- 내 머리 속에 있는 예시 2
	- 마찬가지로, Oauth도 각 플랫폼 마다 수집할 수 있는 항목이 다르다. apple 로그인에는 일련번호를 알면 이메일을 백엔드 딴에서 알아오는 것으로 되어 있고, 카카오는 바로 일련번호와 이메일을 알아 올 수 있다. 클라이언트 측에서 가져올 수 있는 정보가 다르기에 로그인이라는 메소드를 어느 정도 추상화시키고, 파라미터 자체에 oauth를 상속 받는 kakaoLogin나 naverLogin 등을 넣어주는 것이다.
	```kotlin
	fun login(oauth: Oauth){
	
	}
	
	
	//클래스 구현부
	class KAKAOLogin() : Oauth{
	//이메일, 비밀번호 등
	}
	```

추상화와 확장성(종류를 늘릴 수 있다.) 단순히 플랫폼의 이름만 다른게 아니라, 수집하는 개인 정보도 다르기에, oauth 플랫폼의 종류를 enum으로 관리하는 것보다 더 나은 것 같다. 

>Enum [이넘]  
>처음 안드로이드를 할 때 카테고리는 이넘 값으로 줄게요~ 했던게 기억이 난다. ㅋㅋㅋ

## 1.1.4 옵저버 패턴
- 주체
- 객체
- 옵저버  

세 개의 등장인물이 등장한다. 

**주체가 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등의 방식으로 옵저버 목록에 있는 옵저버들 한테 변화를 알리는 것**

트위터나 유튜브에서 구독을 하면 해당 유저가 새 글을 올리면 푸쉬 알림을 보내준다. 이러한 것이 Observe!


----

- 자바의 상속과 구현

|     | extends 상속                                                   | implement 구현                                                  |
| --- | ------------------------------------------------------------ | ------------------------------------------------------------- |
| 기본  | 자식 클래스가 부모 클래스의 변수나 메소드를 상속 받아서 사용한다. 자식 클래스 추가나 확장을 할 수 있다. | 부모 인터페이스를 자식 클래스에서 재정의해서 구현한다. 메소드를 그대로 사용할 수 없다. 반드시 재정의 해야함 |
| 목적  | 재사용성 높이기, 중복성 최소화하기                                          | 상대적으로 관련성이 없는 클래스들을 묶고 싶을때                                    |
| 방법  | 일반 클래스, 추상 클래스                                               | 인터페이스                                                         |

> 그렇다면 코틀린은 상속과 구현을 구분하는가?
> 코틀린의 상속은 `클래스 명(): 상속할 클래스 `이런식으로 한다. 
> 키워드가 아닌 `:`으로 상속을 표현하는데, 상속과 구현을 구분할 수 있을까? 
> 
> -> 결론은 못한다. 그리고 어차피 다중상속이 안된다!
> 	하지만 인터페이스 다중 상속은 가능하다. 목적은 두 인터페이스를 묶는 하나의 클래스를 만드는 용도!


```kotlin
//클래스 구현부
class KAKAOLogin() : Oauth{
//이메일, 비밀번호 등
}

```
책에는 안나와있지만 Kotlin으로 안드로이드의 [observer 패턴](https://velog.io/@changhee09/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-LiveData)을 알아봐보자


## 1.1.5 프록시 패턴과 프록시 서버

**객체에 접근하기 전에 접근에 대한 흐름을 가로채서 객체 앞단의 인터페이스 역할을 하는 디자인 패턴**

- 프록시의 역할
	- 프록시 객체로써 보안, 데이터 검증, 로깅 등에 사용
	- 프록시 서버로 사용
- 프록시 서버
	- 클라이언트와 서버가 통신할때, 서버의 앞단에서 가로채서 클라이언트가 직접적으로 접근하는 것을 막는다. 
	- nginX
		- 한 단계 더 거치도록! 왜? 보안을 강화! -> 실제 포트를 숨기거나, 정적 자원을 gzip 압축하거나, 서버 앞단에서 로깅을 할 수도 있음
	- CloudFlare
		- 디도스 공격 방어
		- HTTPS 구축
		- CORS(Cross-Origin Resource Sharing) 
			- 다른 오리진을 통해 로드하지 못하게! 
				- 오리진 = base url? 프로토콜+호스트이름+포트
				- 프론트에서는 localhost 3000포트를 쓰고, 서버는 12010 포트를 쓴다면, 프록시 서버를 통해 프론트의 요청을 12010번으로 바꾸어 줄 수 있다!
## 1.1.6 이터레이터 패턴
**이터레이터를 사용해서 컬렉션의 요소에 접근하는 패턴**

순회할 수 있는 자료형의 구조와 상관없이 "이터레이터"라는 하나의 인터페이스로 순회가 가능하다.
let

다른 객체라도 같은 배로 순회할 수 있다~!

- js에서는 `for a of b`
- [kotlin](https://philosopher-chan.tistory.com/1303) 에서는 `for (a in b)`
- python에서는 `for i in A` 

## 1.1.7 노출모듈 패턴

**즉시 실행 함수를 통해 접근 제어자를 만드는 패턴!**

접근 제어자
- 자바의 경우 private, public, protected 등 접근 제어자가 존재.
- JS는 없다. 

>즉시 실행 함수
>: 함수를 정의하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용한다.

## 1.1.8 MVC 패턴
> Model, View, Controller
![[Pasted image 20250515194902.png]]

장점
- 재사용성과 확장성이 용이
단점
- 앱이 복잡해질 수록 모델과 뷰의 관계가 복잡해진다.

각각의 역할
- Model
	- DB, 상수, 변수 등 
	- 사각형 안에 글자가 있다면, 해당 박스의 위치 정보, 글자의 내용, 글자 위치, 포맷 등 정보를 가짐.
	- 뷰에서 데이터를 생성하거나 수정하려면 반드시 컨트롤러를 통해 모델을 생성/수정해야 함.
- View
	- UI적인 요소
	- 모델을 기반으로 사용자가 볼 수 있는, 보여지는 화면
	- 모델이 가지고 있는 정보를 가지고 있지 않아야함.
	- 단순히 화면에 그리는 역할만 함.
- Controller
	- 모델과 뷰를 잇는 다리 역할. 메인 로직은 여기에~!
	- 모델과 뷰가 1:1 대응일 필요는 없음(하나 이상의 뷰와 하나 이상의 모델을 연결)
	- 모델과 뷰의 생명주기 관리

예시 
- 스프링의 MVC 패턴
## 1.1.9 MVP 패턴
컨트롤러 대신 Presenter가 들어간다.

뷰와 프리젠터는 1:1이다. -> 더 강한 결합
## 1.1.10 MVVM 패턴
컨트롤러 대신 ViewModel이 들어간다.
![[Pasted image 20250515184715.png]]
ViewModel
- 뷰를 더 추상화한 계층
- 커맨드와 데이터 바인딩을 가진다.
	- 커맨드 : 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
	- 데이터 바인딩 : 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법. 뷰모델을 변경하면 뷰가 변경된다. 함수를 사용하지 않고 값의 대입 만으로 변수 변경이 되어서 편리함
- 뷰-뷰모델은 양방향 데이터 바인딩을 지원.
- UI(뷰)를 코드 수정 없이 재사용할 수 있음
- 단위 테스트가 쉬움


예시
- Vue.js 