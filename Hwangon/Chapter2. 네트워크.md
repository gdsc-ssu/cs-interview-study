## 2.1 네트워크 기초

### 네트워크

- 장치들이 통신 기술을 이용하는 구축하는 연결망의 의미함
- node와 Link가 서로 연결되어 있거나 연결되어 있으며 리소스를 공유하는 집합을 의미함
    - node : server, router, switch 등 네트워크 장비를 의미함
    - ![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled.png?raw=true)

### 2.1.1 처리량과 지연 시간

- 좋은 네트워크 : 많은 처리량을 처리할 수 있으며 지연 시간이 짧고 장애 빈도가 적고 안전한 보안성을 가진 네트워크

**처리량(throughput)**

- 링크 내에서 성공적으로 전달된 데이터의 양의 말함 = 얼만큼의 트랙픽 처리
- 처리량이 충분하다 = 많은 트랙픽을 감당할 수 있다.
- 단위로는 bps(bit per second)를 사용함 : 초당 수신되는 비트의 수
- 트래픽 : 링크 내 흐르는 데이터의 양 _ 서버에 저장된 파일을 클라이언트에서 다운로드할 때 발생되는 데이터의 누적량

대역폭 : 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수를 의미함

**지연시간(latency)**

- 요청이 처리되는 시간을 말함 → 메세지가 두 장치 사이를 왕복하는데 걸리는 시간을 의미
- 지연 시간은 매체 타입, 패킷 크기, 라우터의 패킷 처리 시간에 영향을 받음

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%201.png?raw=true)

### 2.1.2 네트워크 병목 현상 : 토폴로지

**네트워크 토폴로지**

- 노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결 형태를 의미함

트리 토폴로지

- 계층형 토폴로지라고 하며 트리 형태로 배치한 네트워크 구성을 의미
- 노드 추가 삭제가 쉬우며 트래픽이 집중될 때 하위 노드에 영향을 끼칠 수 있음

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%202.png?raw=true)

버스 토폴로지

- 중앙 통신 회선 하나에 여러 개의 노드가 연결되어 공유하는 네트워크 구성을 의미함 LAN에서 많이 사용된다
- 설치 비용이 적고 신뢰성이 우수함 _ 스푸핑에 대한 위험이 존재한다
    - 스푸핑 : LAN 상에서 송신부의 패킷을 송신과 상관없는 다른 호스트에게 가지 않도록 스위칭하는 기능을 마비시키거나 속여서 특정 노드에 해당 패킷이 오도록 처리하는 것을 의미함

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%203.png?raw=true)

)

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%204.png?raw=true)

스타 토폴로지

- 중앙에 있는 노드에 모두가 연결되어있는 구성을 의미함
- 노드 추가 및 에러 탐지 용이, 노드끼리의 간섭이 없음 다만 중앙에 오류가 발생하면 전부 마비되고 설치비용이 비싸다는 단점이 존재함

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%205.png?raw=true)

링형 토폴로지

- 각각의 노드가 양 옆의 두 노드와 연결하여 전체적으로 고리처럼 하나의 연속된 길을 통해 통신하는 구조를 의미함
- 네트워크 구성 변경이 어렵다는 단점이 존재하며 회선에 장애라도 발생하면 네트워크 전체에 큰 영향이 있음

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%206.png?raw=true)

메시 토폴로지

- 망형 토폴리지
- 한 단말에 장애가 발생하더라고 여러 개의 경로가 존재함으로 네트워크 지속적으로 사용할 수 있고, 트래픽 분산 처리도 가능하다. 노드 구축이 어려움 운용비용이 고가임

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%207.png?raw=true)

**병목 현상**

- 토폴로지가 중요한 이유는 병목 현상을 찾을 때의 기준이 되기 때문임
- 병목이 발생하면 어떤 구조의 토폴로지로 구성되어있는지 확인 후 회선을 추가하여 병목 현상을 해결 할 수 있음

### 2.1.3 네트워크 분류

- 규모에 따른 분류 WAN, MAN, LAN

LAN : 근거리 통신에서 사용됨 = 속도 빠름

MAN : 대도시 지연 네트워크 도시와 같은 넓은 지역 운영에 사용된다. = 속도 중간

WAN : 국가 혹은 대륙 같은 더 넓은 지역 운영에 사용된다 = 속도 느림

### 2.1.4 네트워크 성능 분석 명령어

- 주된 병목 원인
    - 네트워크 대역폭
    - 네트워크 토폴로지
    - 서버, CPU, 메모리 사용량
    - 비효율적 네트워크 구성 등
- Ping
    - TCP/IP의 프로토콜인 ICMP 프로토콜을 활용해 동작함
- netstat
    - 접속되어 있는 서비스들의 네트워크 상태를 표시하는데 사용되며 접속, 라우팅 테이블, 네트워크 프로토콜 등 리스트를 보여줌 = 주로 서비스 포트가 열려있는지 확인할 때 사용함
    - 현재 접속하고 있는 사이트 등에 대한 상태 리스트 확인 가능
- nslookup
    - DNS 에 관련된 내용을 확인하기 위해 쓰는 명령어 _ 특정 도메인에 매핑된 IP를 확인하기 위해 사용한다.
    - nslookup
        - [google.com](http://google.com/)
        - naver.com
        - 등 사용 가능
- tracert
    - 윈도우 tracert , 리눅스 traceroute
    - 목적지 노드까지의 네트워크 경로를 확인할 때 사용할 때 사용하는 명령어
    - 어떤 구간에서 명목이 걸리는지 확인할 수 있음

### 2.1.5 네트워크 프로토콜 표준화

- 다른 장치까지 데이터를 주고 받기 위해 설정된 공통된 인터페이스를 말함

## 2.2 TCP/IP 4 계층 모델

### 2.2.1 계층 구조

- OSI 7 계층 TCP/IP 4계층
    - 네트워크 통신 프로토콜의 집합

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%208.png?raw=true)

)

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%209.png?raw=true)

- 어플리케이션 계층
    - appliction : FTP, HTTP, SSH, SMTP, DNS 등 응용 프로그램이 존재함
    - 웹 서비스, 이메일 등 사용자에게 제공하는 계층을 의미함
    - SMTP : 전자 메일을 위한 프로토콜
- 전송 계층
    - 송신자와 수신자를 연결하는 통신 서비스를 제공하는 계층
    - 연결 지향 데이터 스트림, 신뢰성 , 흐름 제어 등을 제공함
    - TCP. UDP가 여기에 해당함
    - _TCP*_
    - 패킷 사이의 순서를 보장하고 연결 지향 프로토콜을 사용해서 연결하여 신뢰성 구축 수신 여부 확인 “가상회선 패킷 교환 방식”을 이용함
    - 각 패킷에 가상회선 식별자가 포함되어 모든 패킷을 전공하면 가상회선이 해체되고 순서대로 도착을 보장함연결 성립 과정 (3way-handshake)
    - ![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2010.png?raw=true)
        
    - SYN : isn 임의의 시퀀스 추가해서 보냄
    - SYN + ACK : 서버의 isn과 클라이언트의 isn에 + 1해서보냄
    - ACK :클라이언트는 서버의 ISN +1 한값을 보냄연결 해제 과정
    - ![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2011.png?raw=true)
        
    - Time_Wait가 존재하는 이유는 : 지연 패킷이 발생했을 경우 대비를 하기 위해
    - 무결성 보장을 위해 존재한다.
    - ![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2012.png?raw=true)
        
    - UDP
    - 순서를 보장하지 않고 수신 여부를 확인하지 않으며 단순히 데이터만 주고 받는 “데이터그램 패킷 교환 방식”을 이용함
    - 패킷이 독립적으로 이동하며 최적의 경로를 선택해 나감, 서로 다른 경로로 도착할 수 있으며 순서가 다를 수 있는 방식을 의미함
    - ![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2013.png?raw=true)
        
- 인터넷 계층
    - 패킷을 ip 주소로 지정된 목적지로 전송하기 위해 사용되는 계층
    - ip,arp,icmp등이 있으며 수신해야할 상대의 주소를 지정하여 데이터 전달
    - 상대방에 제대로 받았는지 보장하지 않는 비연결형적인 특징을 가지고 있음
- 링크 계층
    - 전선, 광섬유, 무선 등으로 실질적으로 데이터를 전달하면 장치 간 신호를 주고받는 규칙을 정하는 계층

유선 LAN(IEEE802.3)

- 전이중화 통신을 사용

전이중화 (Full duplex) 통신

- 양쪽 장치가 동시에 송수신 할 수 있는 방식을 의미
- 고속 이더넷은 대부분 이 방식을 기반으로 통신함

**계층 간 데이터 송수신 과정**

- 요청을 보내면 애플리케이션 → 전송 → 인터넷 계층 → 링크 계층 → 링크 계층 → 인터넷 계층 → 전송 → 애플리케이션 계층 으로 **캡슐화를** 거쳐 전달되고 링크 계층을 통해 해당 서버와 통신하고 해당 서버의 링크 계층으로부터 애플리케이션까지 **비캡슐화** 과정을 거쳐 데이터가 전송된다.

캡슐화 과정

- 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 해당 계층의 헤더를 삽입하는 과정을 의미함
- 비캡슐화 과정 : 프레임 → 패킷 → 세그먼트, 데이터 그램 → 메세지

## 2.3 네트워크 기기

### 2.3.1 네트워크 기기의 처리 범위

상위 계층을 처리하는 기기는 하위 계층을 처리할 수 있지만 그 반대는 불가함

- 애플리케이션 계층 : L7 스위치
- 인터넷 계층 : 라우터, L3 스위치
- 데이터 링크 계층 : L2 스위치, 브리지
- 물리 계층 : NIC, 리피터, AP

### 2.3.2 애플리케이션 계층을 처리하는 기기

**L7 스위치**

- 여러 장비를 연결하고 데이터 통신을 중재하며 목적지가 연결된 포트로만 전기 신호를 보내 데이터를 전송하는 통신 네트워크 장비
- **로드밸런서**라고도 불림 → 서버의 부하를 분산하는 기기, 클라이언트로부터 오는 요청들을 뒤쪽의 여러 서버로 나누는 역할을 함 ⇒ 시스템이 처리할 수 있는 트래픽 증가를 목표로함
- URL.서버 , 캐시, 쿠키들을 기반으로 트래픽을 분산, 바이러스. 불필요한 외부 데이터 필터링 기능, 응용 프로그램 수준의 트래픽 모니터링 지원
- ![https://github.com/wnstj7788/CS/blob/main/NetWork/img/image_(10).png?raw=true](https://security-gom.tistory.com/img/image_(10).png?raw=true)

**L7 스위치 VS L4 스위치**

- L4 스위치는 전송 계층을 처리하는 기기로 스트리밍 관련 서비스에서는 사용할 수 없음 , 메세지를 기반으로 인식하지 못함, **IP와 Port 기반으로 트래픽을 분산함**
- L7은 IP, Port, URL, HTTP Header, 쿠키 등을 기반으로 트래픽을 분산함

**헬스체크**

- 헬스 체크를 통해 정상적인 서버 또는 비정상적인 서버를 판별, 헬스 체크는전송 주기와 재전송 횟수 등을 설정한 이후 반복적으로 서버에 요청을 보내는 것을 말함

ex) TCP 요청을 보냈는데 3_way handshake가 정상적으로 오지 않으면 정상이 아닌거임

**로드밸런서를 이용한 이중화**

- 로드밸런서의 대표적 기능 : 서버 이중화 → 서비스를 안정적으로 운용하기 위해 2개 이상의 서버는 필수적임 → 1개의 서버의 이상이 발생하더라도 서비스는 안정적으로 운영하기 위해
- 0.0.0.12010이 존재하면 → 0.0.0.120111 or 0.0.0.112012로 서빙해줌

### 2.3.3 인터넷 계층을 처리하는 기기

**라우터, L3 스위치**

- 라우터 (소프트웨어 기반 라우팅 )
    - 여러 개의 네트워크를 연결, 분할, 구분 시켜주는 역할
    - 다른 네트워크상에 존재하는 장치끼리 서로 데이터를 주고 받을 때 패킷 소모를 최소화하여 최소 경로로 패킷을 포워딩 하는 장비
- L3 스위치
    - L2 스위치 + 라우팅 기능을 갖춘 장비 = L3 스위치를 라우터라고 해도 무방함 (하드웨어 기반 라우팅 )

### 2.3.4 데이터 링크 계층을 처리하는 기기

**L2 스위치, 브리지**

L2 스위치

- MAC 주소를 MAC 주소 테이블을 통해 관리하며, 연결된 장치로부터 패킷이 왔을 때 패킷 전송을 담당함
- IP 이해 못 해 IP 주소를 기반으로 라우팅은 불가하며 단순히 패킷의 MAC 주소를 읽어 스위칭 하는 역할을 함

브리지

- 두 개의 근거리 LAN을 상호 접속 할 수 있도록 하는 통신망 연결 장치로 , 포트와 포트 사이의 중간 다리 역할을 함 = 통신망의 범위를 확장하고 서로 다른 LAN 등으로 이루어진 하나의 통신망을 구축할 때 사용한다.

### 2.3.5 물리계층을 처리하는 기기

**NIC, 리피터, AP**

NIC

- LAN 카드라고 불리는 녀석, 2대 이상의 컴퓨터 네트워크를 구성하는데 사용함
- 각각을 구분하기 위해 식별번호 MAC 주소가 존재함

리피터

- 약해진 신호를 증폭해서 다른 쪽으로 보내주는 장치
- 현재는 잘 사용하지 않음 → 광테이블의 보급 때문

AP

- Access Point 패킷을 복사하는 기기

## 2.4 IP 주소

- 인터넷 계층에서 사용하는 주소 IP

### 2.4.1 ARP

- 컴퓨터와 컴퓨터 간의 통신 = IP주소에서 ARP를 통해 MAC을 찾아 MAC주소를 기반으로 통신함
- ARP(address Resolution Protocaol) : IP주소로 부터 MAC 주소를 구하는 프로토콜
- 가상 주소인 IP를 통해 실제 주소인 MAC 주소를 찾는 것 → ARP
- 실제 주소인 MAC 에서 가상 주소인 IP를 찾는 것→ RARP

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2014.png?raw=true)

)

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2015.png?raw=true)

- A ⇒ 브로드 캐스트를 이용해서 전체에게 MAC 주소를 찾으라고 알림
- 해당 하는 B가 유니캐스트 ARP Reply를 통해 MAC 전송해줌

> 브로드캐스트 : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에게 전송

> 유니케스트 : 고유 주소로 식별된 하나의 네트워크에 1 : 1 로 데이터를 전송하는 방식

### 2.4.2 홉바이홉 통신

- 통신망에서 각 패킷이 여러 개의 라우터를 건너가는 모습
- 서브 네트워크 안에 있는 라우팅의 라우팅 테이블 IP를 기반으로 패킷을 전달하고 또 전달해 나가며 라우팅을 수행해 최종 목적지까지 패킷을 전달하는 행위를 의미함

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2016.png?raw=true)

**라우팅 테이블**

- 송신자에게 수신자까지 도달하기 위해 라우터에 들어가 있는 목적지 정보들과 가기 위한 방법을 명시해둔 리스트를 의미함
- 게이트워에와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야할 라우터 정보를 가지고 있음

**게이트 웨이**

- 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간 통신을 가능하게 해주는 컴퓨터나 소프트웨어를 일컫는 용어
- 서로 다른 네트워크상의 통신 프로토콜을 변환해주는 역할
- 게이트 웨이를 확인하기 위해 netstat -r 작성하면 볼 수 있음

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2017.png?raw=true)

### 2.4.3 IP 주소 체계

IPv4 : 32비트 8비트로 나누어 표현 ⇒ 123.456.7.9

IPv6 : 64비트 16비트로 나어 표현 ⇒ 2001:db8::ff00:42:8329

**클래스 기반 할당**

- A,B,C,D,E 다섯 개의 클래스로 구분하는 클래스 기반 할당
- A,B,C 는 일대일 통신으로 사용, D는 멀티캐스트 통신, E는 앞으로 사용할 예비용

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2018.png?raw=true)

- 클래스 범위

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2019.png?raw=true)

IP의 낭비를 줄이기 위해 아래 두가지 방식이 등장

**DHCP**

- IP주소 및 통신 매개변수 직접 할당할 필요없이 인터넷 접속시 자동 할당

**NAT**

- 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법
- IPv4 주소 체계만으로 부족한 아이피를 감당하기 위해 공인 IP와 사설 IP로 나누어 처리

![Untitled](https://github.com/wnstj7788/CS/blob/main/NetWork/img/Untitled%2020.png?raw=true)

- 192.168.0.1,2,3,4 ⇒ 사설 IP
- NAT 장비를 통해 하나의 공인 IP 121.165.151.200으로 외부 인터넷 요청 가능
- 홍철 및 가영은 하나의 IP인 121.165.151.200을 기반으로 각각의 다른 IP 를 가지는 것 처럼 사용할 수 있음
- NAT 장비를 통해 사설을 공인으로 공인을 사설로 바꾸는 역할을 수행 할 수 있음

**공유기와 NAT**

- NAT를 사용하는 이유는 여러 대의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함
- 인터넷 하나의 회선을 열고 공유기를 달아서 여러 PC를 연결하는 사용하는 것 → 공유기에 NAT 기능이 탑재 되어있기 때문에 가능함

**NAT 보안**

- NAT 이용하면 내부 네트워크 IP주소와 외부에 들어나는 IP가 다르게 유지 할 수 있기 때문에 내부 네트워크에 대한 어느 정도의 보안이 가능

**NAT 단점**

- 여러 명이 동시에 사용하기 때문에 느려질 수 있음
---
### 질문 정리
1. **내 컴퓨터에서 네이버 홈페이지를 띄우는 과정을 설명하세요**
    - 정답
        
        브라우저에서 www.naver.com을 입력하면 서버 접근을 위해 해당 도메인 이름에 대한 IP 주소를 알아야합니다. 이때, DNS 요청을 하는데 브라우저나 OS의 캐시를 확인 후 없는 경우 ISP의 DNS 서버로 질의합니다. DNS 서버는 보통 Root, TLD, authoritative 로 나누어져 있어 순서대로 쿼리하여 권한 서버에서 실제 IP를 가져옵니다. DNS 쿼리는 UDP를 사용합니다. 만약, CDN이 설정되어 있다면 CDN 서버의 IP를 반환할 수 있습니다. 네이버의 IP가 확인되면 내 컴퓨터의 기본 게이트웨이로 요청을 보내 ISP 네트워크로 이동합니다. 이 요청은 ISP의 동적 라우팅 프로토콜을 통해 여러 라우터를 거쳐 네이버 서버까지 도달하게 됩니다. 이 경로로 TCP 3-way-handshake를 통해 네이버 서버와 연결을 맺고 TLS 핸드셰이크로 HTTPS 암호화를 진행합니다. 이제 GET 요청으로 페이지를 불러와 브라우저에 렌더링하는 과정으로 페이지를 띄우게 됩니다.
        
        > **키워드: DNS, 라우터, TCP, HTTPS**
2. **TCP vs UDP**
    
    - 정답
        
        **신뢰성**을 보장하는 **연결 지향형 프로토콜**로 패킷의 **순서를 보장**하고 **재전송**을 지원합니다. **흐름 제어**와 **혼잡 제어** 기능을 제공합니다. 속도는 비교적 느리지만 신뢰성이 중요할 때 사용합니다. UDP는 반대로 **비연결형 프로토콜**입니다. 데이터 순서를 보장하지 않고 재전송도 하지 않습니다. 흐름 제어와 혼잡 제어 기능도 없습니다. 다만, TCP보다 빨라 DNS, DHCP, 실시간 스트리밍, 게임 등에 사용합니다.
        
        > **키워드: 신뢰성, 연결 지향, 순서 보장, 재전송, 흐름 제어, 혼잡 제어 / 반대**
        
3. **TCP 연결과 종료 과정**
    
    - 정답
        
        3-way-handshake로 연결을 맺고 4-way-handshake로 연결을 종료합니다.
        
        연결은 클라이언트가 서버에게 client isn과 함께 SYN 패킷을 보내면 서버가 이를 확인하고 자신의 isn과 client isn+1이 담긴 SYN-ACK 응답을 보내줍니다. 클라이언트는 이를 확인후 server isn + 1이 담긴 ACK 패킷을 보내 연결을 완료합니다.
        
        종료는 클라이언트가 서버로 FIN 패킷을 보내면 서버는 ACK 응답을 보냅니다. 연결이 종료되면 FIN 응답을 보내고 클라이언트는 이를 확인 후 ACK 응답으로 연결을 종료합니다. 클라이언트가 ACK 패킷을 전송하면 미수신 패킷을 방지하기 위해 TIME_WAIT 상태로 진입하여 일정 시간이 지나면 연결이 완전히 종료됩니다.
        
        > **키워드: SYN, SYN-ACK, ACK / FIN-ACK-FIN-ACK, TIME_WAIT**
        
4. DNS가 UDP를 사용하는 이유
    
    - 정답
        
        DNS는 IP 주소만 불러오기 때문에 패킷의 크기가 작고 연결을 유지할 필요가 없기 때문에 UDP를 사용합니다. 문제가 생기더라도 다시 요청하는 방식으로 진행됩니다.
        
5. **흐름제어와 혼잡제어**
    
    - 정답
        
        흐름 제어는 수신측보다 송신측의 속도가 빠를 경우 데이터 손실을 막기 위한 방법으로 **송신측의 데이터 전송량을 조절하는 작업**입니다. Stop and Wait과 Sliding Window 방식이 있습니다. **Stop and Wait** 방식은 패킷을 하나씩 보내는 동기 방식으로 느리기 때문에 **Sliding Window**를 사용합니다. 수신측의 윈도우 크기로 설정하며 이후 수신측의 ACK에서 남은 버퍼의 크기를 확인하며 버퍼가 모두 차는 경우에는 데이터를 송신하지 않아 재전송을 방지합니다.
        
        TCP 혼잡 제어는 네트워크 혼잡을 방지하기 위해 송신자가 전송 속도를 동적으로 조절하는 메커니즘입니다. 기본적으로 네트워크의 상태를 추측하여, 너무 많은 데이터를 보내서 패킷 손실이 발생하지 않도록 설계되어 있습니다. TCP는 대표적으로 네 가지 혼잡 제어 알고리즘을 사용합니다. 첫 번째는 **Slow Start**로, 연결 초기에 `cwnd` 값을 작게 시작해서 지수적으로 증가시킵니다. 이후 cwnd가 ssthresh 시점 부터는 `cwnd`를 선형적으로 증가시켜(AIMD) 네트워크를 천천히 탐색합니다. 만약 3-ACK-Duplicated로 패킷 손실이 감지되면 **Fast Retransmit**을 통해 손실된 패킷을 빠르게 재전송하고, **Fast Recovery**를 통해 `cwnd`를 절반으로 줄인 후 네트워크 혼잡을 회피하며 전송을 재개합니다. Timeout이 발생하면 1로 줄입니다. 이 방식은 TCP Reno의 대표적인 혼잡 제어 흐름이고, 최근에는 리눅스의 Cubic이나 BBR 같은 더 정교한 알고리즘도 사용되고 있습니다.
        
        핵심은, 혼잡 제어는 단순히 전송 속도를 높이는 것이 아니라, **네트워크 상태에 맞게 조절함으로써 전체적인 성능과 안정성을 높이는 것**이라고 생각합니다.
        
        > **키워드: 흐름제어: 수신, 송신 측 관리(Stop and Wait, Sliding Window) / 혼잡제어: 네트워크 혼잡도 관리(AMID, Slow Start, Fast Retransmit)**
        
6. SACK란?
    
    - 정답
        
        TCP는 일반적으로 누락된 패킷이 있으면 해당 시점부터의 모든 패킷을 재전송해야 합니다. 이를 비효율적이라 판단하고 나온 방식이 SACK(Selective Acknowledgment)입니다. 수신자는 정상적으로 수신한 범위를 명시적으로 알려주고 송신자는 정확히 누락된 데이터만 재전송합니다. 이로인해 불필요한 네트워크 자원 낭비를 방지할 수 있습니다.
        
7. MTU와 MSS
    
    - 정답
        
        MTU는 **전송될 수 있는 최대 크기의 패킷 또는 프레임**으로 이더넷에서는 1500byte입니다. MSS는 **TCP에서 전송할 수 있는 데이터의 최대 크기**로 TCP payload를 의미합니다. 기본적으로 MTU(1500bytes) - IP Header(20bytes) - TCP Header(20bytes) = 1460bytes 입니다.
        
        > **키워드: 패킷의 최대 크기 / 데이터의 최대 크기**